package vulnerabilities

import kotlinx.datetime.Instant
import vulnerabilities.dto.osv.OpenSourceVulnerabilityFormat
import vulnerabilities.dto.osv.PackageX
import java.nio.file.Path
import kotlin.time.Duration

data class VulnerabilityStatistics(
    // how many vulnerabilities are in our dataset
    val numberOfVulnerabilities: Int,
    // what is the time difference between the report date
    // of a vulnerability and the release date of the oldest
    // version to which the vulnerability applies (one entry
    // per vulnerability)
    val timeDifferences: MutableList<Int>,
    // see timeDifferences, just counting how many versions
    // are mapped to one vulnerability
    val versionDifferences: MutableList<Int>
)

class VulnerabilityAnalyzer(private val filePath: Path) {


    private val allVulnerabilities: MutableList<OpenSourceVulnerabilityFormat> =
        VulnerabilityHelper.readVulnerabilitiesFromFile(filePath).toMutableList()


    init {
        removeIncompleteData()
    }

    fun histogram(): Map<Long, Int> {
        var versionsWithoutMatch = 0
        val durations = allVulnerabilities.flatMap { vulnerability ->
            val publishedDate = Instant.parse(vulnerability.published)
            vulnerability.affected.flatMap { affected ->
                val versions = affected.packageX.versions
                affected.ranges.flatMap { range ->
                    range.events.mapNotNull { event ->
                        val introducedVersion = event.introduced
                        val version = versions?.find { it.versionNumber == introducedVersion }
                        if(version == null) {
                            versionsWithoutMatch +=1
                        }
                         version?.released?.let {
                             val versionReleaseDate = Instant.parse(it)
                             return@mapNotNull publishedDate.minus(versionReleaseDate).inWholeDays
                        }
                        return@mapNotNull null
                    }
                }
            }
        }
        println("Versions without match $versionsWithoutMatch")
        val noOutlier = durations.toMutableList()
        println("previous count ${noOutlier.count()}")
            noOutlier.removeAll { it > 900L }
        println("after remove count ${noOutlier.count()}")
        val occurrencesMap = mutableMapOf<Long, Int>()


        for (value in noOutlier) {
            occurrencesMap[value] = occurrencesMap.getOrDefault(value, 0) + 1
        }

        var occurenceCounter100 = 0
        var occurenceCounter200 = 0
        var occurenceCounter300 = 0
        var occurenceCounterLarger = 0
        occurrencesMap.forEach { value, occurence ->
            if (value < 100) {
                occurenceCounter100 += occurence
            } else if(value < 200) {
                occurenceCounter200 += occurence
            } else if(value < 300) {
                occurenceCounter300 += occurence
            } else {
                occurenceCounterLarger += occurence
            }
        }
        val overallOccurences = occurrencesMap.values.sumOf { it }
        println("Overall occurences ${overallOccurences}. Less than 100 $occurenceCounter100, less than 200 $occurenceCounter200, less than 300 $occurenceCounter300, large $occurenceCounterLarger")

        return occurrencesMap
    }

    fun analyze() {


        //TODO: only use vulnerabilities with a specific "introduced" value (precise, but small dataset)
        var noIntroduced = allVulnerabilities.count()
        allVulnerabilities.forEach {
            it.affected.forEach {
                it.ranges.forEach {
                    it.events.removeAll { it.introduced == "0" }
                }
                it.ranges.removeAll { it.events.isEmpty() }
            }
        }
        allVulnerabilities.removeAll { it.affected.none { it.ranges.isNotEmpty() } }
        noIntroduced -= allVulnerabilities.count()

        println(
            "Vulnerabilities with no concrete introduced value $noIntroduced.\n" +
                    "Remaining ${allVulnerabilities.count()}"
        )
        val diffs: MutableList<Duration> = mutableListOf()
        allVulnerabilities.forEach { vulnerability ->
            // Using kotlinx.datetime.Instant
            val publishedInstant = Instant.parse(vulnerability.published)

            // each distinct package is counted separately for the same vulnerability
//            val distinctAffected = vulnerability.affected.distinctBy { it.packageX.name }
            vulnerability.affected.forEach { affected ->
                try {
                    // TODO: this is strange
                    val smallest =
                        vulnerability.affected.minOf { it.ranges.minOf { it.events.minOf { it.introduced } } }
                    affected.packageX.versions?.find { it.versionNumber == smallest }.let { smallestVersion ->
                        smallestVersion?.let {
                            val versionReleaseDate = Instant.parse(it.released)
                            diffs.add(publishedInstant.minus(versionReleaseDate))
                        }
                    }
                } catch (exception: Exception) {
                    println("calculation failed with $exception")
                }
            }
        }
        val avgDays = diffs.sumOf { it.inWholeDays } / diffs.count()
        println("Avg days after version release until published vulnerability $avgDays")

        //TODO: use all vulnerabilities for which we have version information and make the time diff between
        // the vulnerability found date and the latest release before the vulnerability was found (optimistic)

        //TODO: make the diff between the report time and the oldest minor or patch version (maybe realistic?)
//        val haveIntroducedValue = allVulnerabilities.filter { vul ->
//            vul.affected.any { affected ->
//                affected.ranges?.any { range ->
//                    range?.events?.any { event ->
//                        event?.introduced != null && event.introduced != "0"
//                    } ?: false
//                } ?: false
//            }
//        }
    }

    private fun removeIncompleteData() {

        println("Started with ${allVulnerabilities.size} vulnerabilities. \n " +
                "Removing incomplete data.")
        var noIntroducedValue = allVulnerabilities.count()

        allVulnerabilities.forEach {
            it.affected.forEach {
                it.ranges.forEach {
                    it.events.removeAll { it.introduced == "-1" }
                }
                it.ranges.removeAll { it.events.isEmpty() }
            }
        }

        allVulnerabilities.removeAll { it.affected.none { it.ranges.isNotEmpty() } }

        noIntroducedValue -= allVulnerabilities.count()
        var noVersions = allVulnerabilities.count()
        allVulnerabilities.removeAll { it.affected.none { it.packageX.versions?.isNotEmpty() ?: true } }
        noVersions -= allVulnerabilities.count()

        val incompleteInformationCount = noVersions + noIntroducedValue

        println(
            "Vulnerabilities with no introduced value ($noIntroducedValue) or no version information ($noVersions)\n" +
                    "Removed vulnerabilities: $incompleteInformationCount, remaining ${allVulnerabilities.size}. "
        )
    }

}