package vulnerabilities

import dependencies.model.DependencyGraphDto
import http.deps.DepsClient
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import vulnerabilities.dto.OpenSourceVulnerabilityFormat
import vulnerabilities.dto.PackageWithVersions
import java.nio.file.Path
import java.util.*
import kotlin.collections.HashSet

class VulnerabilityAnalyzer(private val depsClient: DepsClient = DepsClient()) {

    private val json = Json

    suspend fun storeVersionsForVulnerablePackages(filePath: Path) {
        val vulnerabilities = readVulnerabilitiesFromFile(filePath)
        val packageWithVersions = getVersionInformationForVulnerablePackages(vulnerabilities)
        packageWithVersions.forEach {
            val outputFile = filePath.resolve("${it.packageX.name}-versions.json").toFile()
            withContext(Dispatchers.IO) {
                outputFile.createNewFile()
                val json = Json { prettyPrint = true }
                val jsonString =
                    json.encodeToString(PackageWithVersions.serializer(), it)
                outputFile.writeText(jsonString)
            }
        }
    }

    private fun readVulnerabilitiesFromFile(filePath: Path): List<OpenSourceVulnerabilityFormat> {
        val directory = filePath.toFile()

        return if (directory.isDirectory) {
            directory.listFiles()?.filter { it.extension == "json" }?.map { jsonFile ->

                json.decodeFromString<OpenSourceVulnerabilityFormat>(jsonFile.absolutePath)
            } ?: emptyList()
        } else {
            emptyList()
        }
    }

    private suspend fun getVersionInformationForVulnerablePackages(vulnerabilities: List<OpenSourceVulnerabilityFormat>)
            : List<PackageWithVersions> {
        val seenPackages = HashSet<String>()
        return vulnerabilities.flatMap { vulnerability ->
            vulnerability.affected.mapNotNull { affected ->
                if (affected.packageX?.name != null &&
                    affected.packageX.ecosystem != null &&
                    !seenPackages.contains(affected.packageX.name)
                ) {
                    val versions = if (affected.packageX.name.contains("/")) {
                        val splitName = affected.packageX.name.split("/")
                        val nameSpace = splitName[0]
                        val name = splitName[1]
                        depsClient.getVersionsForPackage(
                            ecosystem = affected.packageX.ecosystem,
                            name = name,
                            namespace = nameSpace
                        )
                    } else {
                        depsClient.getVersionsForPackage(
                            ecosystem = affected.packageX.ecosystem,
                            name = affected.packageX.name,
                        )
                    }
                    seenPackages.add(affected.packageX.name)
                    return@mapNotNull PackageWithVersions(packageX = affected.packageX, versions = versions)
                } else {
                    null
                }

            }
        }
    }

}